name: 构建Jar包和Windows可执行程序（强制JRE路径版）

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  release:
    types: [ published ]

jobs:
  build:
    runs-on: windows-latest
    env:
      JAR_FULL_PATH: "./target/SpigotPluginCreaterTool.jar"
      EXE_DIR: "./target/exe-win64"
      EXE_FULL_PATH: "./target/exe-win64/mc-plugin-tool.exe"
      LAUNCH4J_CONFIG: "./launch4j.xml"
      MAIN_CLASS: "org.bxwbb.spigotplugincreatertool.HelloApplication"
      TIMEOUT_SECONDS: 180  # 明确设置3分钟超时

    steps:
      - name: 1. 拉取仓库代码
        uses: actions/checkout@v4

      - name: 2. 设置JDK 21（64位）并记录JRE路径
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven
          architecture: x64
      - id: get_jre_path
        run: |
          # 找到JDK中的JRE路径（temurin JDK默认包含JRE）
          $jrePath = Join-Path $env:JAVA_HOME "jre"
          if (-not (Test-Path $jrePath)) {
            # 某些JDK版本JRE在bin同级目录，直接用JAVA_HOME
            $jrePath = $env:JAVA_HOME
          }
          echo "jre_path=$jrePath" >> $env:GITHUB_OUTPUT
          echo "✅ 找到JRE路径：$jrePath"
          # 验证Java可执行
          java -version
        shell: pwsh

      - name: 3. 构建Jar包（验证完整性）
        run: |
          mvn clean package -DskipTests -U
          $jarSize = (Get-Item "${{ env.JAR_FULL_PATH }}").Length
          if ($jarSize -lt 1024) {
            echo "❌ 错误：Jar包过小（可能损坏）！"
            exit 1
          }
          $mainClassInJar = "${{ env.MAIN_CLASS }}".Replace('.', '/') + ".class"
          if (-not (jar tf "${{ env.JAR_FULL_PATH }}" | Select-String -Pattern "$mainClassInJar")) {
            echo "❌ 错误：主类不在Jar包中！"
            exit 1
          }
        shell: pwsh

      - name: 4. 安装并定位Launch4j
        id: find_launch4j
        run: |
          choco install launch4j -y
          $launch4jPath = "C:\Program Files (x86)\launch4j\launch4j.exe"
          if (Test-Path $launch4jPath) {
            echo "launch4j_path=$launch4jPath" >> $env:GITHUB_OUTPUT
          } else {
            echo "❌ 未找到Launch4j！"
            exit 1
          }
        shell: pwsh

      - name: 5. 生成launch4j.xml（强制指定JRE路径，避免查找依赖）
        run: |
          # 直接生成新的配置文件，避免原配置冲突
          $jrePath = "${{ steps.get_jre_path.outputs.jre_path }}"
          $configContent = @"
          <?xml version="1.0" encoding="UTF-8"?>
          <launch4jConfig>
            <dontWrapJar>false</dontWrapJar>
            <jarPath>${{ env.JAR_FULL_PATH }}</jarPath>
            <outfile>${{ env.EXE_FULL_PATH }}</outfile>
            <platform>win64</platform>
            <!-- 强制指定JRE路径，解决找不到JRE的问题 -->
            <jre>
              <path>$jrePath</path>
              <minVersion>21</minVersion>
              <maxVersion></maxVersion>
            </jre>
            <mainClass>${{ env.MAIN_CLASS }}</mainClass>
            <version>0.0.1</version>
            <companyName>BXWBB</companyName>
          </launch4jConfig>
          "@
          # 写入配置文件
          $configContent | Set-Content "${{ env.LAUNCH4J_CONFIG }}" -Encoding UTF8
          echo "✅ 生成新配置文件，强制JRE路径：$jrePath"
          echo "`n最终配置内容："
          Get-Content "${{ env.LAUNCH4J_CONFIG }}" -Encoding UTF8
        shell: pwsh

      - name: 6. 生成EXE（修复超时+监控）
        run: |
          $launch4jPath = "${{ steps.find_launch4j.outputs.launch4j_path }}"
          $timeout = ${{ env.TIMEOUT_SECONDS }}  # 修复变量引用
          echo "=== 启动Launch4j（超时：$timeout秒） ==="
          
          # 启动进程并监控
          $process = Start-Process -FilePath $launch4jPath `
            -ArgumentList "${{ env.LAUNCH4J_CONFIG }}" `
            -NoNewWindow `
            -PassThru `
            -RedirectStandardOutput "./launch4j_out.log" `
            -RedirectStandardError "./launch4j_err.log"
          
          $elapsed = 0
          while (-not $process.HasExited -and $elapsed -lt $timeout) {
            Start-Sleep -Seconds 10
            $elapsed += 10
            # 输出监控信息（包含超时倒计时）
            $remaining = $timeout - $elapsed
            $cpu = (Get-Counter "\Process(launch4j*)\% Processor Time" -ErrorAction SilentlyContinue).CounterSamples.CookedValue
            $mem = (Get-Counter "\Process(launch4j*)\Working Set - Private" -ErrorAction SilentlyContinue).CounterSamples.CookedValue / 1MB
            echo "已运行$elapsed秒 | 剩余$remaining秒 | CPU: $($cpu.ToString('N2'))% | 内存: $($mem.ToString('N2'))MB"
          }
          
          # 处理结果
          if (-not $process.HasExited) {
            echo "`n❌ 超时！强制终止Launch4j"
            $process | Stop-Process -Force
            exit 1
          } else {
            echo "`nLaunch4j退出码：$($process.ExitCode)"
            echo "`n标准输出："
            Get-Content ./launch4j_out.log
            echo "`n错误输出："
            Get-Content ./launch4j_err.log
          
            if ($process.ExitCode -ne 0) {
              echo "`n❌ EXE生成失败！"
              exit 1
            }
          }
          
          if (Test-Path "${{ env.EXE_FULL_PATH }}") {
            echo "`n✅ EXE生成成功：${{ env.EXE_FULL_PATH }}"
          } else {
            echo "`n❌ EXE未生成！"
            exit 1
          }
        shell: pwsh

      - name: 7. 上传产物
        uses: actions/upload-artifact@v4
        with:
          name: mc-plugin-tool-final
          path: |
            ${{ env.JAR_FULL_PATH }}
            ${{ env.EXE_FULL_PATH }}