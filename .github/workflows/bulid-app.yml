name: 构建Jar包和Windows可执行程序

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  release:
    types: [ published ]

jobs:
  build:
    runs-on: windows-latest
    env:
      JAR_FULL_PATH: "./target/SpigotPluginCreaterTool.jar"  # assembly生成的Jar
      EXE_DIR: "./target/exe-win64"
      EXE_FULL_PATH: "./target/exe-win64/mc-plugin-tool.exe"
      LAUNCH4J_CONFIG: "./launch4j.xml"
      MAIN_CLASS: "org.bxwbb.spigotplugincreatertool.HelloApplication"

    steps:
      - name: 1. 拉取仓库代码
        uses: actions/checkout@v4

      - name: 2. 设置JDK 21（64位）
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven
          architecture: x64

      - name: 3. 构建Jar包（验证主类）
        run: |
          mvn clean package -DskipTests -U
          
          # 验证Jar包和主类
          if (-not (Test-Path "${{ env.JAR_FULL_PATH }}")) {
            echo "❌ 错误：Jar包不存在！"
            exit 1
          }
          $mainClassInJar = "${{ env.MAIN_CLASS }}".Replace('.', '/') + ".class"
          if (-not (jar tf "${{ env.JAR_FULL_PATH }}" | Select-String -Pattern "$mainClassInJar")) {
            echo "❌ 错误：主类不在Jar包中！"
            exit 1
          }
          echo "✅ Jar包和主类验证通过"
        shell: pwsh

      - name: 4. 安装并定位32位Launch4j（关键修复）
        id: find_launch4j
        run: |
          echo "=== 安装Launch4j（默认32位） ==="
          choco install launch4j -y
          
          echo "`n=== 搜索32位默认安装路径（优先） ==="
          # 32位程序默认安装目录：C:\Program Files (x86)\launch4j
          $launch4jPath = "C:\Program Files (x86)\launch4j\launch4j.exe"
          
          if (Test-Path $launch4jPath) {
            echo "✅ 找到32位Launch4j：$launch4jPath"
            # 验证工具可执行（输出版本）
            & $launch4jPath --version
            echo "launch4j_path=$launch4jPath" >> $env:GITHUB_OUTPUT
          } else {
            # 备选搜索：Chocolatey可能的安装路径
            $altPath = Get-ChildItem -Path "C:\ProgramData\chocolatey\lib\launch4j" -Filter "launch4j.exe" -Recurse | Select-Object -First 1
            if ($altPath) {
              $launch4jPath = $altPath.FullName
              echo "✅ 找到Launch4j（备选路径）：$launch4jPath"
              echo "launch4j_path=$launch4jPath" >> $env:GITHUB_OUTPUT
            } else {
              echo "❌ 错误：未找到Launch4j！"
              exit 1
            }
          }
        shell: pwsh

      - name: 5. 更新launch4j.xml配置（确保生成64位EXE）
        run: |
          echo "=== 确保配置生成64位EXE ==="
          $configContent = Get-Content "${{ env.LAUNCH4J_CONFIG }}" -Encoding UTF8
          # 强制设置platform为win64（即使工具是32位）
          $configContent = $configContent -replace '<platform>.*?</platform>', "<platform>win64</platform>"
          # 同步jarPath和outfile路径
          $configContent = $configContent -replace '<jarPath>.*?</jarPath>', "<jarPath>${{ env.JAR_FULL_PATH }}</jarPath>"
          $configContent = $configContent -replace '<outfile>.*?</outfile>', "<outfile>${{ env.EXE_FULL_PATH }}</outfile>"
          # 保存配置
          $configContent | Set-Content "${{ env.LAUNCH4J_CONFIG }}" -Encoding UTF8
          
          echo "`n更新后的关键配置："
          Select-String -Path "${{ env.LAUNCH4J_CONFIG }}" -Pattern '<platform>|<jarPath>|<outfile>'
        shell: pwsh

      - name: 6. 生成Windows 64位EXE（捕获详细日志）
        run: |
          $launch4jPath = "${{ steps.find_launch4j.outputs.launch4j_path }}"
          echo "=== 使用32位Launch4j生成64位EXE ==="
          New-Item -ItemType Directory -Path "${{ env.EXE_DIR }}" -Force | Out-Null
          
          # 执行生成并捕获完整日志
          & $launch4jPath "${{ env.LAUNCH4J_CONFIG }}" 2>&1 | Tee-Object -FilePath ./launch4j_log.txt
          
          # 检查结果
          if ($LASTEXITCODE -ne 0) {
            echo "`n❌ EXE生成失败！详细日志："
            Get-Content ./launch4j_log.txt
            exit 1
          }
          if (-not (Test-Path "${{ env.EXE_FULL_PATH }}")) {
            echo "`n❌ 错误：EXE文件未生成！"
            exit 1
          }
          echo "`n✅ 64位EXE生成成功：${{ env.EXE_FULL_PATH }}"
        shell: pwsh

      - name: 7. 上传最终产物
        uses: actions/upload-artifact@v4
        with:
          name: mc-plugin-tool-final
          path: |
            ${{ env.JAR_FULL_PATH }}
            ${{ env.EXE_FULL_PATH }}